<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>ZIP/HTML Runner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: dark; }
    body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: #121212;
      color: #eee;
    }
    header {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: #1e1e1e;
      box-shadow: 0 2px 6px rgba(0,0,0,0.6);
      border-radius: 0 0 12px 12px;
    }
    label.btn {
      background: #2a2a2a;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.5);
      transition: background 0.2s;
    }
    label.btn:hover { background: #3a3a3a; }
    input[type=file] { display: none; }
    select {
      background: #2a2a2a;
      color: #eee;
      border: none;
      border-radius: 8px;
      padding: 6px 10px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
    #status { flex: 1; font-size: 14px; opacity: 0.8; }
    #stage {
      width: 100%;
      height: calc(100vh - 70px);
      border: none;
      border-radius: 12px;
      box-shadow: 0 0 12px rgba(0,0,0,0.7);
    }
    #fullscreenBtn {
      position: fixed;
      top: 12px;
      right: 12px;
      background: #2a2a2a;
      color: #eee;
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.6);
      opacity: 0.3;
      transition: opacity 0.3s;
      z-index: 1000;
    }
    #fullscreenBtn:hover { opacity: 1; }
    #progressContainer {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 6px;
      background: #2a2a2a;
    }
    #progressBar {
      width: 0%;
      height: 100%;
      background: #4caf50;
      transition: width 0.2s;
    }
  </style>
</head>
<body>
  <header>
    <label class="btn">
      <strong>Select ZIP</strong>
      <input id="zip" type="file" accept=".zip" />
    </label>
    <label class="btn">
      <strong>Select HTML</strong>
      <input id="htmlFile" type="file" accept=".html,.htm" />
    </label>
    <select id="fileSelect"></select>
    <div id="status">No file loaded</div>
  </header>

  <iframe id="stage" sandbox="allow-scripts allow-same-origin allow-downloads" referrerpolicy="no-referrer"></iframe>
  <button id="fullscreenBtn">⛶</button>
  <div id="progressContainer"><div id="progressBar"></div></div>

<script src="https://cdn.jsdelivr.net/npm/fflate/umd/index.js"></script>
<script>
  const statusEl = document.getElementById('status');
  const stage = document.getElementById('stage');
  const zipInput = document.getElementById('zip');
  const htmlInput = document.getElementById('htmlFile');
  const fileSelect = document.getElementById('fileSelect');
  const fullscreenBtn = document.getElementById('fullscreenBtn');
  const progressBar = document.getElementById('progressBar');
  const header = document.querySelector('header');

  let entries = {};
  let blobMap = {};

  function mimeType(name) {
    const lower = name.toLowerCase();
    if (lower.includes('.html') || lower.includes('.htm')) return 'text/html';
    if (lower.includes('.js')) return 'application/javascript';
    if (lower.includes('.css')) return 'text/css';
    if (lower.includes('.wasm')) return 'application/wasm';
    if (lower.includes('.data')) return 'application/octet-stream';
    if (lower.includes('.unityweb')) return 'application/octet-stream';
    if (lower.includes('.json')) return 'application/json';
    if (lower.includes('.png')) return 'image/png';
    if (lower.includes('.jpg') || lower.includes('.jpeg')) return 'image/jpeg';
    if (lower.includes('.gif')) return 'image/gif';
    if (lower.includes('.webp')) return 'image/webp';
    if (lower.includes('.mp3')) return 'audio/mpeg';
    if (lower.includes('.ogg')) return 'audio/ogg';
    if (lower.includes('.mp4')) return 'video/mp4';
    return 'application/octet-stream';
  }

  function isUnityBuild() {
    const names = Object.keys(entries).map(n => n.toLowerCase());
    return names.some(n => n.includes('.wasm')) ||
           names.some(n => n.includes('.unityweb')) ||
           names.some(n => n.includes('unityloader.js'));
  }

  // Patch HTML to replace resource paths with blob URLs
  function patchUnityHtml(name) {
    let raw = new TextDecoder().decode(entries[name]);
    for (const [fname, blobUrl] of Object.entries(blobMap)) {
      const safe = fname.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
      raw = raw.replace(new RegExp(safe, 'g'), blobUrl);
    }
    return raw;
  }

  async function launchFile(name) {
    if (!entries[name]) return;
    if (isUnityBuild()) {
      const patched = patchUnityHtml(name);
      const blob = new Blob([patched], { type: 'text/html' });
      stage.src = URL.createObjectURL(blob);
      statusEl.textContent = `Running Unity: ${name}`;
    } else {
      const raw = new TextDecoder().decode(entries[name]);
      stage.srcdoc = raw;
      statusEl.textContent = `Running: ${name}`;
    }
  }

  fileSelect.addEventListener('change', () => {
    const name = fileSelect.value;
    if (name) launchFile(name);
  });

  zipInput.addEventListener('change', async () => {
    const file = zipInput.files?.[0];
    if (!file) return;
    statusEl.textContent = `Reading ZIP: ${file.name}…`;
    const buf = new Uint8Array(await file.arrayBuffer());
    progressBar.style.width = '5%';
    const unzipped = fflate.unzipSync(buf);
    const names = Object.keys(unzipped);
    const total = names.length;
    entries = {};
    blobMap = {};
    for (let idx = 0; idx < names.length; idx++) {
      const name = names[idx];
      const bytes = unzipped[name];
      entries[name] = bytes;
      blobMap[name] = URL.createObjectURL(new Blob([bytes], { type: mimeType(name) }));
      const percent = Math.round(((idx + 1) / total) * 80) + 10;
      progressBar.style.width = percent + '%';
      const sizeKB = (bytes.length / 1024).toFixed(1);
      statusEl.textContent = `Extracting ${idx + 1}/${total}: ${name} (${sizeKB} KB)`;
    }
    fileSelect.innerHTML = '';
    names.forEach(n => {
      const opt = document.createElement('option');
      opt.value = n;
      opt.textContent = n;
      fileSelect.appendChild(opt);
    });
    const entry = names.find(n => /index\.html?$/i.test(n)) ||
                  names.find(n => /\.html?$/i.test(n)) ||
                  names[0];
    if (entry) {
      fileSelect.value = entry;
      await launchFile(entry);
      progressBar.style.width = '100%';
      statusEl.textContent = `Finished extraction (${total} files). Running: ${entry}`;
      setTimeout(() => progressBar.style.width = '0%', 1500);
    } else {
      statusEl.textContent = 'No HTML entry point found in ZIP.';
      progressBar.style.width = '0%';
    }
  });

  htmlInput.addEventListener('change', async () => {
    const file = htmlInput.files?.[0];
    if (!file) return;
    statusEl.textContent = `Loading ${file.name}…`;
    const raw = await file.text();
    const blob = new Blob([raw], { type: 'text/html' });
    stage.src = URL.createObjectURL(blob);
    statusEl.textContent = `Running: ${file.name}`;
    fileSelect.innerHTML = '';
    const opt = document.createElement('option');
    opt.value = file.name;
    opt.textContent = file.name;
    fileSelect.appendChild(opt);
    fileSelect.value = file.name;
  });

  // Fullscreen toggle with fallbacks
  fullscreenBtn.addEventListener('click', () => {
    const elem = stage;
    if (!document.fullscreenElement &&
        !document.webkitFullscreenElement &&
        !document.msFullscreenElement) {
      if (elem.requestFullscreen) {
        elem.requestFullscreen();
      } else if (elem.webkitRequestFullscreen) {
        elem.webkitRequestFullscreen();
      } else if (elem.msRequestFullscreen) {
        elem.msRequestFullscreen();
      } else if (document.documentElement.requestFullscreen) {
        document.documentElement.requestFullscreen();
      }
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
      }
    }
  });

  // Auto-hide header bar
  setTimeout(() => {
    header.classList.add('hidden');
  }, 2000);
  document.addEventListener('mousemove', (e) => {
    if (e.clientY < 50) {
      header.classList.remove('hidden');
    } else {
      if (!header.matches(':hover')) {
        header.classList.add('hidden');
      }
    }
  });
  header.addEventListener('mouseenter', () => {
    header.classList.remove('hidden');
  });
  header.addEventListener('mouseleave', () => {
    header.classList.add('hidden');
  });
  </script>
</body>
</html>
