<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>ZIP/HTML Runner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: dark; }
    body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: #121212;
      color: #eee;
    }
    header {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: #1e1e1e;
      box-shadow: 0 2px 6px rgba(0,0,0,0.6);
      border-radius: 0 0 12px 12px;
    }
    label.btn {
      background: #2a2a2a;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.5);
      transition: background 0.2s;
    }
    label.btn:hover { background: #3a3a3a; }
    input[type=file] { display: none; }
    select {
      background: #2a2a2a;
      color: #eee;
      border: none;
      border-radius: 8px;
      padding: 6px 10px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
    #status { flex: 1; font-size: 14px; opacity: 0.8; }
    #stage {
      width: 100%;
      height: calc(100vh - 70px);
      border: none;
      border-radius: 12px;
      box-shadow: 0 0 12px rgba(0,0,0,0.7);
    }
    #fullscreenBtn {
      position: fixed;
      top: 12px;
      right: 12px;
      background: #2a2a2a;
      color: #eee;
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.6);
      opacity: 0.3;
      transition: opacity 0.3s;
      z-index: 1000;
    }
    #fullscreenBtn:hover { opacity: 1; }
    #progressContainer {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 6px;
      background: #2a2a2a;
    }
    #progressBar {
      width: 0%;
      height: 100%;
      background: #4caf50;
      transition: width 0.2s;
    }
  </style>
</head>
<body>
  <header>
    <label class="btn">
      <strong>Select ZIP</strong>
      <input id="zip" type="file" accept=".zip" />
    </label>
    <label class="btn">
      <strong>Select HTML</strong>
      <input id="htmlFile" type="file" accept=".html,.htm" />
    </label>
    <select id="fileSelect"></select>
    <div id="status">No file loaded</div>
  </header>

  <iframe id="stage" sandbox="allow-scripts allow-downloads" referrerpolicy="no-referrer"></iframe>
  <button id="fullscreenBtn">⛶</button>
  <div id="progressContainer"><div id="progressBar"></div></div>

  <script src="https://cdn.jsdelivr.net/npm/fflate/umd/index.js"></script>
  <script>
    const statusEl = document.getElementById('status');
    const stage = document.getElementById('stage');
    const zipInput = document.getElementById('zip');
    const htmlInput = document.getElementById('htmlFile');
    const fileSelect = document.getElementById('fileSelect');
    const fullscreenBtn = document.getElementById('fullscreenBtn');
    const progressBar = document.getElementById('progressBar');

    let entries = {}, map = {};

    // Utility: guess MIME type
    function mimeType(name) {
      if (name.endsWith('.js')) return 'application/javascript';
      if (name.endsWith('.wasm')) return 'application/wasm';
      if (name.endsWith('.data')) return 'application/octet-stream';
      if (name.endsWith('.html') || name.endsWith('.htm')) return 'text/html';
      return 'text/plain';
    }

    // Patch Unity HTML to replace resource paths with blob URLs
    function patchUnityHtml(name) {
      let raw = new TextDecoder().decode(entries[name]);
      for (const [fname, blobUrl] of Object.entries(map)) {
        // Replace only relative references
        const safe = fname.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
        raw = raw.replace(new RegExp(safe, 'g'), blobUrl);
      }
      return raw;
    }

    function launchFile(name) {
      if (!entries[name]) return;
      const isUnity = /\.html?$/.test(name) &&
                      Object.keys(entries).some(f => f.endsWith('.wasm') || f.includes('UnityLoader.js'));

      if (isUnity) {
        const patched = patchUnityHtml(name);
        const blob = new Blob([patched], { type: 'text/html' });
        stage.src = URL.createObjectURL(blob);
        statusEl.textContent = `Running Unity: ${name}`;
      } else {
        const raw = new TextDecoder().decode(entries[name]);
        stage.srcdoc = raw;
        statusEl.textContent = `Running: ${name}`;
      }
    }

    fileSelect.addEventListener('change', () => {
      const name = fileSelect.value;
      if (name) launchFile(name);
    });

    // Handle ZIP upload
    zipInput.addEventListener('change', async () => {
      const file = zipInput.files?.[0];
      if (!file) return;
      statusEl.textContent = 'Reading ZIP…';

      const buf = new Uint8Array(await file.arrayBuffer());
      progressBar.style.width = '10%';

      const unzipped = fflate.unzipSync(buf);
      progressBar.style.width = '60%';

      entries = {};
      map = {};
      for (const [name, bytes] of Object.entries(unzipped)) {
        entries[name] = bytes;
        map[name] = URL.createObjectURL(new Blob([bytes], { type: mimeType(name) }));
      }

      progressBar.style.width = '90%';

      fileSelect.innerHTML = '';
      Object.keys(entries).forEach(n => {
        const opt = document.createElement('option');
        opt.value = n;
        opt.textContent = n;
        fileSelect.appendChild(opt);
      });

      if (Object.keys(entries).length) {
        fileSelect.value = Object.keys(entries)[0];
        launchFile(Object.keys(entries)[0]);
        progressBar.style.width = '100%';
        setTimeout(() => progressBar.style.width = '0%', 1000);
      } else {
        statusEl.textContent = 'No files found in ZIP.';
        progressBar.style.width = '0%';
      }
    });

    // Handle single HTML upload
    htmlInput.addEventListener('change', async () => {
      const file = htmlInput.files?.[0];
      if (!file) return;
      statusEl.textContent = `Loading ${file.name}…`;

      const raw = await file.text();
      const blob = new Blob([raw], { type: 'text/html' });
      stage.src = URL.createObjectURL(blob);
      statusEl.textContent = `Running: ${file.name}`;
      fileSelect.innerHTML = '';
      const opt = document.createElement('option');
      opt.value = file.name;
      opt.textContent = file.name;
      fileSelect.appendChild(opt);
      fileSelect.value = file.name;
    });

    // Fullscreen toggle
    fullscreenBtn.addEventListener('click', () => {
      if (!document.fullscreenElement) {
        stage.requestFullscreen();
      } else {
        document.exitFullscreen();
      }
    });
  </script>
</body>
</html>
