<!doctype html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>ZIP/HTML Runner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: dark; }
    body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: #121212;
      color: #eee;
    }
    header {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: #1e1e1e;
      box-shadow: 0 2px 6px rgba(0,0,0,0.6);
      border-radius: 0 0 12px 12px;
    }
    label.btn {
      background: #2a2a2a;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.5);
      transition: background 0.2s;
    }
    label.btn:hover { background: #3a3a3a; }
    input[type=file] { display: none; }
    select {
      background: #2a2a2a;
      color: #eee;
      border: none;
      border-radius: 8px;
      padding: 6px 10px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
    #status { flex: 1; font-size: 14px; opacity: 0.8; }
    #stage {
      width: 100%;
      height: calc(100vh - 70px);
      border: none;
      border-radius: 12px;
      box-shadow: 0 0 12px rgba(0,0,0,0.7);
    }
    #fullscreenBtn {
      position: fixed;
      top: 12px;
      right: 12px;
      background: #2a2a2a;
      color: #eee;
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.6);
      opacity: 0.3;
      transition: opacity 0.3s;
      z-index: 1000;
    }
    #fullscreenBtn:hover { opacity: 1; }
    #progressContainer {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 6px;
      background: #2a2a2a;
    }
    #progressBar {
      width: 0%;
      height: 100%;
      background: #4caf50;
      transition: width 0.2s;
    }
  </style>
</head>
<body>
  <header>
    <label class="btn">
      <strong>Select ZIP</strong>
      <input id="zip" type="file" accept=".zip" />
    </label>
    <label class="btn">
      <strong>Select HTML</strong>
      <input id="htmlFile" type="file" accept=".html,.htm" />
    </label>
    <label class="btn">
      <strong>Select SWF</strong>
      <input id="swfFile" type="file" accept=".swf" />
    </label>
    <select id="fileSelect"></select>
    <div id="status">No file loaded</div>
  </header>

  <iframe id="stage" sandbox="allow-scripts allow-same-origin allow-downloads" referrerpolicy="no-referrer"></iframe>
  <button id="fullscreenBtn">⛶</button>
  <div id="progressContainer"><div id="progressBar"></div></div>

  <script src="https://cdn.jsdelivr.net/npm/fflate/umd/index.js"></script>
  <script src="https://unpkg.com/@ruffle-rs/ruffle"></script>
  <script>
    const statusEl = document.getElementById('status');
    const stage = document.getElementById('stage');
    const zipInput = document.getElementById('zip');
    const htmlInput = document.getElementById('htmlFile');
    const swfInput = document.getElementById('swfFile');
    const fileSelect = document.getElementById('fileSelect');
    const fullscreenBtn = document.getElementById('fullscreenBtn');
    const progressBar = document.getElementById('progressBar');

    let entries = {};
    let blobMap = {};

    function mimeType(name) {
      const lower = name.toLowerCase();
      if (lower.endsWith('.html') || lower.endsWith('.htm')) return 'text/html';
      if (lower.endsWith('.js')) return 'application/javascript';
      if (lower.endsWith('.css')) return 'text/css';
      if (lower.endsWith('.wasm')) return 'application/wasm';
      if (lower.includes('.data') || lower.includes('.unityweb')) return 'application/octet-stream';
      if (lower.endsWith('.json')) return 'application/json';
      if (lower.endsWith('.png')) return 'image/png';
      if (lower.endsWith('.jpg') || lower.endsWith('.jpeg')) return 'image/jpeg';
      if (lower.endsWith('.gif')) return 'image/gif';
      if (lower.endsWith('.webp')) return 'image/webp';
      if (lower.endsWith('.mp3')) return 'audio/mpeg';
      if (lower.endsWith('.ogg')) return 'audio/ogg';
      if (lower.endsWith('.mp4')) return 'video/mp4';
      if (lower.endsWith('.swf')) return 'application/x-shockwave-flash';
      return 'application/octet-stream';
    }

    function patchHtmlWithBlobs(name) {
      let raw = new TextDecoder().decode(entries[name]);
      raw = raw.replace(/file:\/\/\/?([^\s"'>]+)/g, (match, path) => {
        const clean = path.replace(/^\/+/, '');
        if (blobMap[clean]) return blobMap[clean];
        return match;
      });
      raw = raw.replace(/(src|href|poster)=["']([^"']+)["']/g, (match, attr, path) => {
        const clean = path.replace(/^\/+/, '');
        if (/^(https?:)?\/\//i.test(path)) return match;
        if (blobMap[clean]) return `${attr}="${blobMap[clean]}"`;
        return match;
      });
      for (const [fname, blobUrl] of Object.entries(blobMap)) {
        const safe = fname.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
        const re = new RegExp(`["']${safe}["']`, 'g');
        raw = raw.replace(re, `"${blobUrl}"`);
      }
      return raw;
    }

    async function launchFile(name) {
      if (!entries[name]) return;
      const shortName = name.replace(/^[^/]+\//, '');
      if (shortName.toLowerCase().endsWith('.swf')) {
        const blobUrl = blobMap[shortName];
        const container = document.createElement('div');
        container.style.width = "100%";
        container.style.height = "80vh";
        const ruffle = window.RufflePlayer.newest();
        const player = ruffle.createPlayer();
        container.appendChild(player);
        stage.replaceWith(container);
        player.load(blobUrl);
        statusEl.textContent = `Running SWF: ${name}`;
        return;
      }
      const patched = patchHtmlWithBlobs(name);
      const blob = new Blob([patched], { type: 'text/html' });
      stage.src = URL.createObjectURL(blob);
      statusEl.textContent = `Running: ${name}`;
    }

    fileSelect.addEventListener('change', () => {
      const name = fileSelect.value;
      if (name) launchFile(name);
    });

    zipInput.addEventListener('change', async () => {
      const file = zipInput.files?.[0];
      if (!file) return;
      statusEl.textContent = `Reading ZIP: ${file.name}…`;
      const buf = new Uint8Array(await file.arrayBuffer());
      progressBar.style.width = '5%';

      const unzipped = fflate.unzipSync(buf);
      const names = Object.keys(unzipped);
      const total = names.length;
      entries = {};
      blobMap = {};

      for (let idx = 0; idx < names.length; idx++) {
        const name = names[idx];
        const bytes = unzipped[name];
        entries[name] = bytes;
        const shortName = name.replace(/^[^/]+\//, '');
        blobMap[shortName] = URL.createObjectURL(new Blob([bytes], { type: mimeType(name) }));
        const percent = Math.round(((idx + 1) / total) * 80) + 10;
        progressBar.style.width = percent + '%';
      }

      fileSelect.innerHTML = '';
      const runnableNames = names.filter(n => /\.html?$/i.test(n));
      runnableNames.forEach(n => {
        const opt = document.createElement('option');
        opt.value = n;
        opt.textContent = n;
        fileSelect.appendChild(opt);
      });

      const entry = runnableNames.find(n => /index\.html?$/i.test(n)) || runnableNames[0];
      if (entry) {
        fileSelect.value = entry;
        await launchFile(entry);
        progressBar.style.width = '100%';
        statusEl.textContent = `Finished extraction (${total} files). Running: ${entry}`;
        setTimeout(() => progressBar.style.width = '0%', 1500);
      } else {
        statusEl.textContent = 'No HTML entry point found in ZIP.';
        progressBar.style.width = '0%';
      }
    });

    htmlInput.addEventListener('change', async () => {
      const file = htmlInput.files?.[0];
      if (!file) return;
      statusEl.textContent = `Loading ${file.name}…`;
      const raw = await file.text();
      const blob = new Blob([raw], { type: 'text/html' });
      stage.src = URL.createObjectURL(blob);
      statusEl.textContent = `Running: ${file.name}`;
      fileSelect.innerHTML = '';
      const opt = document.createElement('option');
      opt.value = file.name;
      opt.textContent = file.name;
      fileSelect.appendChild(opt);
      fileSelect.value = file.name;
    });

    // NEW: SWF input handler
    swfInput.addEventListener('change', async () => {
      const file = swfInput.files?.[0];
      if (!file) return;
      statusEl.textContent = `Loading SWF: ${file.name}…`;
      const blobUrl = URL.createObjectURL(file);

      // Create container sized like the iframe
      const container = document.createElement('div');
      container.id = "swfStage";
      container.style.width = "100%";
      container.style.height = stage.style.height || "80vh"; // match iframe height
      container.style.display = "block";

      // Create Ruffle player
      const ruffle = window.RufflePlayer.newest();
      const player = ruffle.createPlayer();
      player.style.width = "100%";
      player.style.height = "100%";

      container.appendChild(player);

      // Replace iframe with SWF container
      stage.replaceWith(container);

      player.load(blobUrl);
      statusEl.textContent = `Running SWF: ${file.name}`;
    });


    fullscreenBtn.addEventListener('click', () => {
      // Find whichever element is currently being used (iframe or SWF container)
      const swfStage = document.getElementById('swfStage');
      const elem = swfStage || stage;

      if (!document.fullscreenElement) {
        if (elem.requestFullscreen) {
          elem.requestFullscreen();
        } else if (elem.webkitRequestFullscreen) {
          elem.webkitRequestFullscreen();
        } else if (elem.msRequestFullscreen) {
          elem.msRequestFullscreen();
        }
      } else {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
          document.msExitFullscreen();
        }
      }
    });

    stage.setAttribute("tabindex", "0");
    stage.addEventListener("load", () => {
      stage.focus();
    });

    window.addEventListener("keydown", (e) => {
      if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.key)) {
        e.preventDefault();
      }
      if (stage.contentWindow) {
        const forwarded = new KeyboardEvent("keydown", {
          key: e.key,
          code: e.code,
          keyCode: e.keyCode,
          which: e.which,
          altKey: e.altKey,
          ctrlKey: e.ctrlKey,
          shiftKey: e.shiftKey,
          metaKey: e.metaKey,
          bubbles: true,
          cancelable: true
        });
        stage.contentWindow.dispatchEvent(forwarded);
      }
    });
  </script>
</body>
</html>