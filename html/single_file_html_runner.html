<!doctype html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>ZIP/HTML Runner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: dark; }
    body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: #121212;
      color: #eee;
    }
    header {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: #1e1e1e;
      box-shadow: 0 2px 6px rgba(0,0,0,0.6);
      border-radius: 0 0 12px 12px;
    }
    label.btn {
      background: #2a2a2a;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.5);
      transition: background 0.2s;
    }
    label.btn:hover { background: #3a3a3a; }
    input[type=file] { display: none; }
    select {
      background: #2a2a2a;
      color: #eee;
      border: none;
      border-radius: 8px;
      padding: 6px 10px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
    #status { flex: 1; font-size: 14px; opacity: 0.8; }
    #stage {
      width: 100%;
      height: calc(100vh - 70px);
      border: none;
      border-radius: 12px;
      box-shadow: 0 0 12px rgba(0,0,0,0.7);
    }
    #fullscreenBtn {
      position: fixed;
      top: 12px;
      right: 12px;
      background: #2a2a2a;
      color: #eee;
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.6);
      opacity: 0.3;
      transition: opacity 0.3s;
      z-index: 1000;
    }
    #fullscreenBtn:hover { opacity: 1; }
    #progressContainer {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 6px;
      background: #2a2a2a;
    }
    #progressBar {
      width: 0%;
      height: 100%;
      background: #4caf50;
      transition: width 0.2s;
    }
  </style>
</head>
<body>
  <header>
    <label class="btn">
      <strong>Select ZIP</strong>
      <input id="zip" type="file" accept=".zip" />
    </label>
    <label class="btn">
      <strong>Select HTML</strong>
      <input id="htmlFile" type="file" accept=".html,.htm" />
    </label>
    <select id="fileSelect"></select>
    <div id="status">No file loaded</div>
  </header>

  <iframe id="stage" sandbox="allow-scripts allow-same-origin allow-downloads" referrerpolicy="no-referrer"></iframe>
  <button id="fullscreenBtn">⛶</button>
  <div id="progressContainer"><div id="progressBar"></div></div>

<script src="https://cdn.jsdelivr.net/npm/fflate/umd/index.js"></script>
<script>
  const statusEl = document.getElementById('status');
  const stage = document.getElementById('stage');
  const zipInput = document.getElementById('zip');
  const htmlInput = document.getElementById('htmlFile');
  const fileSelect = document.getElementById('fileSelect');
  const fullscreenBtn = document.getElementById('fullscreenBtn');
  const progressBar = document.getElementById('progressBar');
  const header = document.querySelector('header');

  let entries = {};
  let blobMap = {};

  function mimeType(name) {
    const lower = name.toLowerCase();
    if (lower.endsWith('.html') || lower.endsWith('.htm')) return 'text/html';
    if (lower.endsWith('.js')) return 'application/javascript';
    if (lower.endsWith('.css')) return 'text/css';
    if (lower.endsWith('.wasm')) return 'application/wasm';
    if (lower.includes('.data') || lower.includes('.unityweb')) return 'application/octet-stream';
    if (lower.endsWith('.json')) return 'application/json';
    if (lower.endsWith('.png')) return 'image/png';
    if (lower.endsWith('.jpg') || lower.endsWith('.jpeg')) return 'image/jpeg';
    if (lower.endsWith('.gif')) return 'image/gif';
    if (lower.endsWith('.webp')) return 'image/webp';
    if (lower.endsWith('.mp3')) return 'audio/mpeg';
    if (lower.endsWith('.ogg')) return 'audio/ogg';
    if (lower.endsWith('.mp4')) return 'video/mp4';
    return 'application/octet-stream';
  }

  // Patch HTML/JS to replace resource paths with blob URLs
  function patchHtmlWithBlobs(name) {
    let raw = new TextDecoder().decode(entries[name]);

    // Rewrite file:// references
    raw = raw.replace(/file:\/\/\/?([^\s"'>]+)/g, (match, path) => {
      const clean = path.replace(/^\/+/, '');
      if (blobMap[clean]) {
        console.log('Rewriting file:// reference:', match, '→', blobMap[clean]);
        return blobMap[clean];
      }
      console.warn('Unresolved file:// reference:', path);
      return match;
    });

    // Rewrite src/href/poster attributes
    raw = raw.replace(/(src|href|poster)=["']([^"']+)["']/g, (match, attr, path) => {
      const clean = path.replace(/^\/+/, '');
      if (blobMap[clean]) {
        console.log(`Rewriting ${attr}:`, path, '→', blobMap[clean]);
        return `${attr}="${blobMap[clean]}"`;
      }
      console.warn(`Unresolved ${attr}:`, path);
      return match;
    });

    // Rewrite quoted string literals inside JS/HTML that match filenames
    for (const [fname, blobUrl] of Object.entries(blobMap)) {
      const safe = fname.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
      const re = new RegExp(`["']${safe}["']`, 'g');
      if (re.test(raw)) {
        console.log('Rewriting string literal:', fname, '→', blobUrl);
        raw = raw.replace(re, `"${blobUrl}"`);
      }
    }

    return raw;
  }

  async function launchFile(name) {
    if (!entries[name]) return;
    const patched = patchHtmlWithBlobs(name);
    const blob = new Blob([patched], { type: 'text/html' });
    stage.src = URL.createObjectURL(blob);
    statusEl.textContent = `Running: ${name}`;
  }

  fileSelect.addEventListener('change', () => {
    const name = fileSelect.value;
    if (name) launchFile(name);
  });

  zipInput.addEventListener('change', async () => {
    const file = zipInput.files?.[0];
    if (!file) return;
    statusEl.textContent = `Reading ZIP: ${file.name}…`;
    const buf = new Uint8Array(await file.arrayBuffer());
    progressBar.style.width = '5%';

    const unzipped = fflate.unzipSync(buf);
    const names = Object.keys(unzipped);
    const total = names.length;
    entries = {};
    blobMap = {};

    for (let idx = 0; idx < names.length; idx++) {
      const name = names[idx];
      try {
        const bytes = unzipped[name];
        entries[name] = bytes;

        // normalize: strip leading folder (e.g. "twitch-tetris/")
        const shortName = name.replace(/^[^/]+\//, '');

        blobMap[shortName] = URL.createObjectURL(new Blob([bytes], { type: mimeType(name) }));
        const percent = Math.round(((idx + 1) / total) * 80) + 10;
        progressBar.style.width = percent + '%';
        const sizeKB = (bytes.length / 1024).toFixed(1);
        statusEl.textContent = `Extracting ${idx + 1}/${total}: ${name} (${sizeKB} KB)`;
      } catch (err) {
        console.error('Error extracting', name, err);
        statusEl.textContent = `Error extracting ${name}`;
      }
    }

    console.log('blobMap keys (normalized):', Object.keys(blobMap));

    fileSelect.innerHTML = '';
    names.forEach(n => {
      const opt = document.createElement('option');
      opt.value = n;
      opt.textContent = n;
      fileSelect.appendChild(opt);
    });

    const entry = names.find(n => /index\.html?$/i.test(n)) ||
                  names.find(n => /\.html?$/i.test(n)) ||
                  names[0];
    if (entry) {
      fileSelect.value = entry;
      await launchFile(entry);
      progressBar.style.width = '100%';
      statusEl.textContent = `Finished extraction (${total} files). Running: ${entry}`;
      setTimeout(() => progressBar.style.width = '0%', 1500);
    } else {
      statusEl.textContent = 'No HTML entry point found in ZIP.';
      progressBar.style.width = '0%';
    }
  });

  htmlInput.addEventListener('change', async () => {
    const file = htmlInput.files?.[0];
    if (!file) return;
    statusEl.textContent = `Loading ${file.name}…`;
    const raw = await file.text();
    const blob = new Blob([raw], { type: 'text/html' });
    stage.src = URL.createObjectURL(blob);
    statusEl.textContent = `Running: ${file.name}`;
    fileSelect.innerHTML = '';
    const opt = document.createElement('option');
    opt.value = file.name;
    opt.textContent = file.name;
    fileSelect.appendChild(opt);
    fileSelect.value = file.name;
  });

  // Fullscreen toggle with fallbacks
  fullscreenBtn.addEventListener('click', () => {
    const elem = stage;
    if (!document.fullscreenElement &&
        !document.webkitFullscreenElement &&
        !document.msFullscreenElement) {
      if (elem.requestFullscreen) {
        elem.requestFullscreen();
      } else if (elem.webkitRequestFullscreen) {
        elem.webkitRequestFullscreen();
      } else if (elem.msRequestFullscreen) {
        elem.msRequestFullscreen();
      } else if (document.documentElement.requestFullscreen) {
        document.documentElement.requestFullscreen();
      }
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
      }
    }
  });

    // Ensure the iframe grabs focus when loaded
  stage.setAttribute("tabindex", "0"); // make iframe focusable
  stage.addEventListener("load", () => {
    stage.focus();
    console.log("Stage iframe focused for keyboard input");
  });

  // Forward key events from parent to iframe if needed
  window.addEventListener("keydown", (e) => {
    // prevent Google Sites from scrolling with arrow keys
    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.key)) {
      e.preventDefault();
    }
    // send the event into the iframe
    if (stage.contentWindow) {
      stage.contentWindow.dispatchEvent(new KeyboardEvent("keydown", e));
    }
  });

  // Auto-hide header bar
  setTimeout(() => {
    header.classList.add('hidden');
  }, 2000);

  document.addEventListener('mousemove', (e) => {
    if (e.clientY < 50) {
      header.classList.remove('hidden');
    } else {
      if (!header.matches(':hover')) {
        header.classList.add('hidden');
      }
    }
  });

  header.addEventListener('mouseenter', () => {
    header.classList.remove('hidden');
  });

  header.addEventListener('mouseleave', () => {
    header.classList.add('hidden');
  });
</script>
</body>
</html>
