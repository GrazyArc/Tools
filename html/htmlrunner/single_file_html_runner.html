<!doctype html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>ZIP/HTML/Unity Runner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: dark; }
    body {
      margin: 0;
      padding: 0; /* Ensures the body fits the window */
      font-family: system-ui, sans-serif;
      background: #121212;
      color: #eee;
      /* Prevent accidental scrolling outside of the game area */
      overflow: hidden; 
    }
    header {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: #1e1e1e;
      box-shadow: 0 2px 6px rgba(0,0,0,0.6);
      border-radius: 0 0 12px 12px;
      z-index: 10;
      height: 46px; /* Fixed height for header content */
    }
    label.btn {
      background: #2a2a2a;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.5);
      transition: background 0.2s;
      white-space: nowrap;
    }
    label.btn:hover { background: #3a3a3a; }
    input[type=file] { display: none; }
    select {
      background: #2a2a2a;
      color: #eee;
      border: none;
      border-radius: 8px;
      padding: 6px 10px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.5);
      min-width: 150px;
    }
    #status { flex: 1; font-size: 14px; opacity: 0.8; }
    
    /* NEW: Container to manage the full height below the header */
    #stageContainer {
      padding: 12px;
      height: calc(100vh - 46px - 24px); /* 46px (header) + 24px (top/bottom padding) */
      box-sizing: border-box;
    }

    .stage-element {
      width: 100%;
      height: 100%; /* Fill the container */
      border: 3px solid #333; /* Default border */
      border-radius: 12px;
      box-shadow: 0 0 12px rgba(0,0,0,0.7);
      transition: border-color 0.2s, box-shadow 0.2s;
    }
    
    /* NEW: Visual cue when the element has focus */
    .stage-element.focused {
      border-color: #4caf50; /* Green border when focused */
      box-shadow: 0 0 20px rgba(76, 175, 80, 0.7);
    }
    
    /* NEW: Visual cue when the element loses focus */
    .stage-element.blurry {
      border-color: #f44336; /* Red border when unfocused */
      box-shadow: 0 0 20px rgba(244, 67, 54, 0.7);
    }
    
    #fullscreenBtn {
      position: fixed;
      top: 12px;
      right: 12px;
      background: #2a2a2a;
      color: #eee;
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.6);
      opacity: 0.3;
      transition: opacity 0.3s;
      z-index: 1000;
    }
    /* Style for Lock Cursor Button */
    #lockCursorBtn {
      position: fixed;
      top: 12px;
      right: 60px;
      background: #2a2a2a;
      color: #eee;
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.6);
      opacity: 0.3;
      transition: opacity 0.3s;
      z-index: 1000;
    }
    #fullscreenBtn:hover, #lockCursorBtn:hover { opacity: 1; }
    #progressContainer {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 6px;
      background: #2a2a2a;
      z-index: 10;
    }
    #progressBar {
      width: 0%;
      height: 100%;
      background: #4caf50;
      transition: width 0.2s;
    }

    /* --- Debug Console Styles --- */
    #debugConsole {
        position: fixed;
        bottom: 0;
        right: 0;
        width: 400px;
        max-height: 50vh;
        background: rgba(0, 0, 0, 0.85);
        border: 1px solid #333;
        border-radius: 8px 0 0 0;
        overflow-y: auto;
        font-family: monospace;
        font-size: 10px;
        color: #ddd;
        padding: 8px;
        z-index: 20;
        box-shadow: -4px -4px 10px rgba(0, 0, 0, 0.5);
        transition: transform 0.3s ease-in-out;
        transform: translateY(0);
    }
    #debugConsole.hidden {
        transform: translateY(100%);
    }
    #debugConsole h4 {
        margin: 0 0 5px 0;
        padding-bottom: 5px;
        border-bottom: 1px dashed #333;
        cursor: pointer;
        color: #4caf50;
    }
    .log-item {
        padding: 2px 0;
        border-bottom: 1px dotted #222;
        line-height: 1.3;
        word-break: break-all;
    }
    .log-item:last-child { border-bottom: none; }
    .log-item.warn { color: #ffeb3b; }
    .log-item.error { color: #f44336; }
    .log-item.info { color: #81d4fa; }
  </style>
</head>
<body>
  <header>
    <label class="btn">
      <strong>Select ZIP (HTML/Unity)</strong>
      <input id="zip" type="file" accept=".zip" />
    </label>
    <label class="btn">
      <strong>Select HTML</strong>
      <input id="htmlFile" type="file" accept=".html,.htm" />
    </label>
    <label class="btn">
      <strong>Select SWF</strong>
      <input id="swfFile" type="file" accept=".swf" />
    </label>
    <select id="fileSelect"></select>
    <div id="status">No file loaded</div>
  </header>

  <div id="stageContainer">
    <iframe id="stage" class="stage-element blurry"
            tabindex="0"
            sandbox="allow-scripts allow-same-origin allow-downloads allow-pointer-lock allow-forms allow-modals allow-fullscreen"
            allowfullscreen
            referrerpolicy="no-referrer">
    </iframe>
  </div>
  
  <button id="lockCursorBtn" title="Click to lock cursor (for FPS games)">ðŸ”’</button>
  <button id="fullscreenBtn">â›¶</button>
  <div id="progressContainer"><div id="progressBar"></div></div>

  <!-- Debug Console UI -->
  <div id="debugConsole">
      <h4 id="debugToggle">Runner Debug Log (Click to Hide)</h4>
      <div id="logContent"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/fflate/umd/index.js"></script>
  <script src="https://unpkg.com/@ruffle-rs/ruffle"></script>

<script>
  const statusEl = document.getElementById('status');
  const stage = document.getElementById('stage');
  const stageContainer = document.getElementById('stageContainer');
  let currentStageElement = stage;
  const zipInput = document.getElementById('zip');
  const htmlInput = document.getElementById('htmlFile');
  const swfInput = document.getElementById('swfFile');
  const fileSelect = document.getElementById('fileSelect');
  const fullscreenBtn = document.getElementById('fullscreenBtn');
  const lockCursorBtn = document.getElementById('lockCursorBtn');
  const progressBar = document.getElementById('progressBar');
  const debugConsole = document.getElementById('debugConsole');
  const logContent = document.getElementById('logContent');

  let entries = {};
  let blobMap = {};
  let mapKeys = [];

  // Global logging function
  function log(message, type = 'info') {
    const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
    const formattedMessage = `[${timestamp}] ${message}`;
    
    if (type === 'error') console.error(formattedMessage);
    else if (type === 'warn') console.warn(formattedMessage);
    else console.log(formattedMessage);

    const logItem = document.createElement('div');
    logItem.className = `log-item ${type}`;
    logItem.textContent = formattedMessage;
    logContent.appendChild(logItem);
    
    logContent.scrollTop = logContent.scrollHeight;
  }

  // Toggle debug console visibility
  document.getElementById('debugToggle').addEventListener('click', () => {
    debugConsole.classList.toggle('hidden');
  });

  // Function to handle focus state and visual cue (Red/Green)
  function handleStageFocus(isFocused) {
      const targetElement = currentStageElement; 
      if (!targetElement) return;

      if (isFocused) {
          targetElement.classList.add('focused');
          targetElement.classList.remove('blurry');
          log('Game Stage gained input focus (clicks/keys captured).', 'info');
      } else {
          targetElement.classList.remove('focused');
          targetElement.classList.add('blurry');
          log('Game Stage lost input focus. Click on the game to continue.', 'warn');
      }
  }

  // Set up focus/blur listeners on the stage element and its contents
  function setupFocusListeners() {
      // Clean up previous listeners if they exist
      currentStageElement.removeEventListener('focus', () => handleStageFocus(true));
      currentStageElement.removeEventListener('blur', () => handleStageFocus(false));

      // Add listeners to the main stage element (iframe or div)
      currentStageElement.addEventListener('focus', () => handleStageFocus(true));
      currentStageElement.addEventListener('blur', () => handleStageFocus(false));
      
      // Crucial: For the iframe, we also need to detect focus on the inner document body
      if (currentStageElement === stage && stage.contentWindow) {
          try {
             // Use capture phase (true) to catch events bubbling up from the inner document
             stage.contentWindow.addEventListener('focus', () => handleStageFocus(true), true);
             stage.contentWindow.addEventListener('blur', () => handleStageFocus(false), true);
          } catch (e) {
             // Fails if contentWindow is cross-origin or restricted
             log(`Could not attach contentWindow focus listeners: ${e.message}`, 'error');
          }
      }
  }

  // Utility function to reset the display to the original iframe
  function resetStageToIframe() {
    // 1. Remove Ruffle container if it exists
    const swfStage = document.getElementById('swfStage');
    if (swfStage && swfStage.parentNode) {
      swfStage.replaceWith(stage);
      currentStageElement = stage;
      stage.classList.add('stage-element');
      // Set the default unfocused state
      stage.classList.add('blurry'); 
      stage.classList.remove('focused');
    }
    // 2. Setup listeners for the iframe
    setupFocusListeners();
  }
</script>
<script>
  function mimeType(name) {
    const lower = name.toLowerCase();
    if (lower.endsWith('.html') || lower.endsWith('.htm')) return 'text/html';
    if (lower.endsWith('.js')) return 'application/javascript';
    if (lower.endsWith('.css')) return 'text/css';
    if (lower.endsWith('.wasm')) return 'application/wasm';
    if (lower.includes('.data') || lower.includes('.unityweb')) return 'application/octet-stream'; 
    if (lower.endsWith('.json')) return 'application/json';
    if (lower.endsWith('.png')) return 'image/png';
    if (lower.endsWith('.jpg') || lower.endsWith('.jpeg')) return 'image/jpeg';
    if (lower.endsWith('.gif')) return 'image/gif';
    if (lower.endsWith('.webp')) return 'image/webp';
    if (lower.endsWith('.mp3')) return 'audio/mpeg';
    if (lower.endsWith('.ogg')) return 'audio/ogg';
    if (lower.endsWith('.mp4')) return 'video/mp4';
    if (lower.endsWith('.swf')) return 'application/x-shockwave-flash';
    return 'application/octet-stream';
  }

  // Path resolution function used by the injected shim inside the game iframe
  window.runnerResolveBlobUrl = function(path) {
    if (!path) {
        log(`INTERNAL ERROR: runnerResolveBlobUrl called with null/empty path.`, 'error');
        return null;
    }
    const pathString = String(path);
    log(`ENGINE REQUEST: Looking for path "${pathString}"...`, 'info');
    
    const clean = pathString.replace(/^["']|["']$/g, '').replace(/^\.?\/+/, '').split(/[?#]/)[0];

    const resolvedUrl = blobMap[clean] || null;

    if (resolvedUrl) {
        log(`RESOLVED (Exact File Match): "${pathString}" -> ${resolvedUrl.substring(0, 40)}...`, 'info');
        return resolvedUrl;
    }

    const dirPrefix = clean + '/';
    const isDirectoryPrefix = mapKeys.some(key => key.startsWith(dirPrefix));

    if (isDirectoryPrefix) {
        log(`RESOLVED (Directory Prefix): "${pathString}" is a folder prefix. Returning original path.`, 'info');
        return pathString; 
    }
    
    const knownUnityFolders = ['StreamingAssets', 'TemplateData', 'Build', 'Data'];
    if (knownUnityFolders.includes(clean)) {
         log(`FALLBACK RESOLVE (Known Folder): "${pathString}" is a common Unity folder, returning original path to allow engine lookup.`, 'warn');
         return pathString;
    }

    log(`FAILED TO RESOLVE: No file or folder found for "${pathString}". This is likely the missing resource.`, 'error');
    return pathString; 
  }

  // Patches HTML content to use Blob URLs and inject the path shim
  function patchHtmlWithBlobs(name) {
    let raw = new TextDecoder().decode(entries[name]);
    let patchesApplied = 0;
    
    raw = raw.replace(/(src|href|poster)=["']([^"']+)["']/gi, (match, attr, path) => {
      if (/^(https?:)?\/\//i.test(path)) return match;
      const blobUrl = window.runnerResolveBlobUrl(path);
      if (blobUrl && blobUrl.startsWith('blob:')) {
          patchesApplied++;
          return `${attr}="${blobUrl}"`;
      }
      return match;
    });

    raw = raw.replace(/(\w+Url\s*:\s*["'])([^"']+)(["'])/g, (match, prefix, path, suffix) => {
        const blobUrl = window.runnerResolveBlobUrl(path);
        if (blobUrl && blobUrl.startsWith('blob:')) {
            patchesApplied++;
            return `${prefix}${blobUrl}${suffix}`;
        }
        return match;
    });

    raw = raw.replace(/(useWebWorkers\s*:\s*|webWorkerUrl\s*:\s*).+/g, (match) => {
        patchesApplied++;
        log('PATCHED: Disabled Web Workers to force single-threaded mode.', 'warn');
        return `useWebWorkers: false, // Patched by ZIP Runner to force single-threaded mode`;
    });
    
    for (const [fname, blobUrl] of Object.entries(blobMap)) {
      if (!blobUrl || !blobUrl.startsWith('blob:')) continue; 
      
      const safe = fname.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
      raw = raw.replace(new RegExp(`(["'])${safe}\\1`, 'g'), (match, quote) => {
        if (raw.includes(match)) {
            patchesApplied++;
            return `${quote}${blobUrl}${quote}`;
        }
        return match;
      });
    }

    const injectionScriptContent = 
        '<script>\n' +
        '  // UNITY PATH RESOLUTION SHIM\n' +
        '  if (typeof Module === \'undefined\') { var Module = {}; }\n' +
        '\n' +
        '  Module.locateFile = function(path) {\n' +
        '    try {\n' +
        '        const resolvedUrl = window.parent.runnerResolveBlobUrl(path);\n' +
        '        if (resolvedUrl) {\n' +
        '            return resolvedUrl;\n' +
        '        }\n' +
        '    } catch (e) {\n' +
        '        console.error(\'UNITY SHIM ERROR:\', e);\n' +
        '    }\n' +
        '    return path; \n' +
        '  };\n' +
        '  \n' +
        '  if (typeof UnityLoader === \'object\' && typeof UnityLoader.locateFile === \'function\') {\n' +
        '      UnityLoader.locateFile = Module.locateFile;\n' +
        '  }\n' +
        '  \n' +
        '  console.log(\'Runner: Module.locateFile shim injected successfully.\');\n' +
        '<\/script>\n';

    raw = raw.replace(/<\/body>/i, injectionScriptContent + '</body>');

    log(`HTML Patching Complete. Total patches applied: ${patchesApplied}. Unity LocateFile Shim injected.`);
    return raw;
  }
</script>
<script>
  async function launchFile(name) {
    if (!entries[name]) return;
    logContent.innerHTML = '';
    log(`Attempting to launch: ${name}`);
    const fileNameOnly = name.split('/').pop();
    
    resetStageToIframe();

    if (fileNameOnly.toLowerCase().endsWith('.swf')) {
      const blobUrl = blobMap[fileNameOnly];
      
      const container = document.createElement('div');
      container.id = "swfStage";
      container.className = "stage-element blurry";
      
      stage.replaceWith(container);
      currentStageElement = container;
      setupFocusListeners();

      const ruffle = window.RufflePlayer.newest();
      const player = ruffle.createPlayer();
      player.style.width = "100%";
      player.style.height = "100%";
      container.appendChild(player);
      
      player.load(blobUrl);
      statusEl.textContent = `Running SWF: ${name}`;
      log(`SWF content loaded into Ruffle.`, 'info');
      return;
    }
    
    try {
      const patched = patchHtmlWithBlobs(name);
      const blob = new Blob([patched], { type: 'text/html' });
      const blobUrl = URL.createObjectURL(blob);
      stage.src = blobUrl;
      statusEl.textContent = `Running: ${name} (Unity/HTML)`;
      log(`Iframe source set to patched blob URL.`, 'info');
    } catch (e) {
        log(`Error during HTML patching/launch: ${e.message}`, 'error');
    }
  }
</script>
<script>
  zipInput.addEventListener('change', async () => {
    const file = zipInput.files?.[0];
    if (!file) return;
    
    resetStageToIframe();
    logContent.innerHTML = '';
    
    statusEl.textContent = `Reading ZIP: ${file.name}â€¦`;
    log(`Starting ZIP extraction for ${file.name}.`);
    
    try {
        const buf = new Uint8Array(await file.arrayBuffer());
        progressBar.style.width = '5%';

        const unzipped = fflate.unzipSync(buf);
        const names = Object.keys(unzipped);
        mapKeys = names;
        const total = names.length;
        entries = {};
        blobMap = {};
        log(`ZIP contains ${total} files. Starting aggressive path mapping.`, 'info');

        for (let idx = 0; idx < names.length; idx++) {
          const path = names[idx];
          const bytes = unzipped[path];
          
          if (path.endsWith('/')) continue;

          entries[path] = bytes;
          
          const blob = new Blob([bytes], { type: mimeType(path) });
          const url = URL.createObjectURL(blob);
          
          blobMap[path] = url;
          
          const parts = path.split('/');
          for (let i = 0; i < parts.length - 1; i++) { 
            const subPath = parts.slice(i + 1).join('/');
            if (!blobMap[subPath]) {
              blobMap[subPath] = url;
            }
          }
          
          const percent = Math.round(((idx + 1) / total) * 80) + 10;
          progressBar.style.width = percent + '%';
        }
        log('File data loaded into memory and aggressive blob map created.', 'info');

        fileSelect.innerHTML = '';
        const runnableNames = names.filter(n => /\.html?$/i.test(n) || /\.swf$/i.test(n));
        runnableNames.forEach(n => {
          const opt = document.createElement('option');
          opt.value = n;
          opt.textContent = n;
          fileSelect.appendChild(opt);
        });

        const entry = runnableNames.find(n => /index\.html?$/i.test(n)) || runnableNames.find(n => /\.html?$/i.test(n)) || runnableNames[0];
        if (entry) {
          fileSelect.value = entry;
          await launchFile(entry);
          progressBar.style.width = '100%';
          setTimeout(() => progressBar.style.width = '0%', 1500);
        } else {
          statusEl.textContent = 'No HTML or SWF entry point found in ZIP.';
          log('No runnable entry point found.', 'error');
          progressBar.style.width = '0%';
        }
    } catch (e) {
        statusEl.textContent = `Error processing ZIP: ${e.message}`;
        log(`FATAL ZIP ERROR: ${e.message}`, 'error');
        progressBar.style.width = '0%';
    }
  });
</script>
<script>
  htmlInput.addEventListener('change', async () => {
    const file = htmlInput.files?.[0];
    if (!file) return;
    
    resetStageToIframe();
    logContent.innerHTML = '';
    
    statusEl.textContent = `Loading ${file.name}â€¦`;
    log(`Loading single HTML file: ${file.name}`);
    
    try {
        const raw = await file.text();
        const blob = new Blob([raw], { type: 'text/html' });
        stage.src = URL.createObjectURL(blob);
        statusEl.textContent = `Running: ${file.name}`;
        log(`Single HTML file loaded directly. Blob mapping skipped.`, 'warn');
        
        fileSelect.innerHTML = '';
        const opt = document.createElement('option');
        opt.value = file.name;
        opt.textContent = file.name;
        fileSelect.appendChild(opt);
        fileSelect.value = file.name;
    } catch (e) {
        log(`Error loading single HTML file: ${e.message}`, 'error');
    }
  });
</script>
<script>
  swfInput.addEventListener('change', async () => {
    const file = swfInput.files?.[0];
    if (!file) return;
    
    statusEl.textContent = `Loading SWF: ${file.name}â€¦`;
    log(`Loading single SWF file: ${file.name}`);
    
    try {
        const blobUrl = URL.createObjectURL(file);
        
        const container = document.createElement('div');
        container.id = "swfStage";
        container.className = "stage-element blurry";
        
        currentStageElement.replaceWith(container);
        currentStageElement = container;
        setupFocusListeners();

        const ruffle = window.RufflePlayer.newest();
        const player = ruffle.createPlayer();
        player.style.width = "100%";
        player.style.height = "100%";
        container.appendChild(player);
        
        player.load(blobUrl);
        statusEl.textContent = `Running SWF: ${file.name}`;
        log(`SWF content loaded into Ruffle.`, 'info');
    } catch (e) {
        log(`Error loading single SWF file: ${e.message}`, 'error');
    }
  });
</script>
<script>
  fullscreenBtn.addEventListener('click', () => {
    const elem = currentStageElement;
    if (!document.fullscreenElement) {
      try {
        if (elem.requestFullscreen) elem.requestFullscreen();
        else if (elem.webkitRequestFullscreen) elem.webkitRequestFullscreen();
        else if (elem.msRequestFullscreen) elem.msRequestFullscreen();
        else {
          log('Fullscreen API not supported by this browser.', 'error');
        }
      } catch (e) {
        log(`Fullscreen request failed (Permission Denied). Error: ${e.message}`, 'error');
      }
    } else {
      if (document.exitFullscreen) document.exitFullscreen();
      else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
      else if (document.msExitFullscreen) document.msExitFullscreen();
    }
  });

  function updatePointerLockBtn() {
    if (document.pointerLockElement) {
      lockCursorBtn.textContent = 'ðŸ”“';
      lockCursorBtn.title = 'Click to release cursor lock';
    } else {
      lockCursorBtn.textContent = 'ðŸ”’';
      lockCursorBtn.title = 'Click to lock cursor (for FPS games)';
    }
  }

  document.addEventListener('pointerlockchange', () => {
    if (document.pointerLockElement) {
      log('Pointer Lock ACHIEVED successfully.', 'info');
    } else {
      log('Pointer Lock RELEASED (by user or system).', 'info');
    }
    updatePointerLockBtn();
  });

  document.addEventListener('pointerlockerror', (e) => {
    log('Pointer Lock FAILED. This is likely due to parent iframe restrictions.', 'error');
    updatePointerLockBtn();
  });

  lockCursorBtn.addEventListener('click', () => {
    if (document.pointerLockElement) {
      document.exitPointerLock();
      return;
    }
    
    const elem = currentStageElement;
    let target = elem;
    if (elem === stage && stage.contentWindow && stage.contentWindow.document.body) {
        target = stage.contentWindow.document.body;
    }

    if (target.requestPointerLock) {
      try {
        target.requestPointerLock();
        log(`Attempting to lock pointer to target: ${target.tagName}#${target.id || 'body'}...`, 'info');
      } catch (e) {
        log(`Pointer Lock request threw an exception: ${e.message}`, 'error');
      }
    } else {
      log('Pointer Lock API not supported on this element or browser.', 'error');
    }
  });
  updatePointerLockBtn();
</script>
<script>
  // Initial setup: ensure the stage element is focusable
  stage.setAttribute("tabindex", "0");
  
  stage.addEventListener("load", () => {
    const w = stage.contentWindow;

    // 1. Setup focus listeners immediately after load
    setupFocusListeners(); 
    handleStageFocus(false); // Start in unfocused state (red border)

    // 2. Reset/Shim Local Storage (Ensures memory map is fresh for every game)
    log('Iframe loaded. Attempting to reset memory map (localStorage shim)...');
    try {
      const t = "__runner_storage_test__";
      w.localStorage.setItem(t, "1");
      w.localStorage.removeItem(t);
      log('SUCCESS: Native localStorage access confirmed and reset.', 'info');
    } catch (_) {
      const mem = new Map(); 
      w.localStorage = {
        getItem(k){ return mem.has(k) ? mem.get(k) : null; },
        setItem(k,v){ mem.set(String(k), String(v)); },
        removeItem(k){ mem.delete(k); },
        clear() {
          mem.clear();
          log('SHIM: In-memory map cleared for new game.', 'warn');
        },
        key(i) {
          return Array.from(mem.keys())[i] ?? null;
        },
        get length() {
          return mem.size;
        }
      };
      w.sessionStorage = w.sessionStorage ?? w.localStorage; 
      log('SHIM APPLIED: Using in-memory shim for persistence. Memory map reset complete.', 'warn');
    }

    // 3. Delayed Focus (Crucial for Unity engine start and input readiness)
    setTimeout(() => {
        // Only focus the outer iframe/stage element. Let the user click inside to get full input.
        stage.focus(); 
        log('Engine start: Applied delayed focus. Game is ready for the first click.', 'info');
    }, 100); 
  });
</script>
<script>
  // Forward keyboard events (especially arrow keys) to the iframe
  window.addEventListener("keydown", (e) => {
    // Prevent default scroll behavior for arrow keys and space when running a game
    if (currentStageElement.classList.contains('focused') && 
        ["ArrowUp","ArrowDown","ArrowLeft","ArrowRight", "Space"].includes(e.key)) {
      e.preventDefault();
    }
    
    // Dispatch event to the iframe content if it's the current stage
    if (currentStageElement === stage && stage.contentWindow) {
      const forwarded = new KeyboardEvent("keydown", {
        key: e.key,
        code: e.code,
        keyCode: e.keyCode,
        which: e.which,
        altKey: e.altKey,
        ctrlKey: e.ctrlKey,
        shiftKey: e.shiftKey,
        metaKey: e.metaKey,
        bubbles: true,
        cancelable: true
      });
      stage.contentWindow.dispatchEvent(forwarded);
    }
  });
  
  // Try to force focus into the iframe/game on any click on the runner page
  document.body.addEventListener('click', () => {
    if (currentStageElement) {
        currentStageElement.focus();
        
        // For HTML/Unity games, attempt to focus the inner body for the most complete input capture
        if (currentStageElement === stage && stage.contentWindow && stage.contentWindow.document.body) {
            stage.contentWindow.document.body.focus();
        }
    }
  });
</script>
</body>
</html>