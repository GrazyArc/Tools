<!doctype html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>ZIP/HTML/Unity Runner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: dark; }
    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, sans-serif;
      background: #121212;
      color: #eee;
      overflow: hidden; 
    }
    header {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: #1e1e1e;
      box-shadow: 0 2px 6px rgba(0,0,0,0.6);
      border-radius: 0 0 12px 12px;
      z-index: 10;
      height: 46px; 
    }
    label.btn {
      background: #2a2a2a;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.5);
      transition: background 0.2s;
      white-space: nowrap;
    }
    label.btn:hover { background: #3a3a3a; }
    input[type=file] { display: none; }
    select {
      background: #2a2a2a;
      color: #eee;
      border: none;
      border-radius: 8px;
      padding: 6px 10px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.5);
      min-width: 150px;
    }
    #status { flex: 1; font-size: 14px; opacity: 0.8; }
    
    #stageContainer {
      padding: 12px;
      height: calc(100vh - 46px - 24px); 
      box-sizing: border-box;
    }

    .stage-element {
      width: 100%;
      height: 100%; 
      border: 3px solid #333; 
      border-radius: 12px;
      box-shadow: 0 0 12px rgba(0,0,0,0.7);
      transition: border-color 0.2s, box-shadow 0.2s;
    }
    
    .stage-element.focused {
      border-color: #4caf50; 
      box-shadow: 0 0 20px rgba(76, 175, 80, 0.7);
    }
    
    .stage-element.blurry {
      border-color: #f44336; 
      box-shadow: 0 0 20px rgba(244, 67, 54, 0.7);
    }
    
    .control-btn {
      position: fixed;
      top: 12px;
      background: #2a2a2a;
      color: #eee;
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.6);
      opacity: 0.5;
      transition: opacity 0.3s, transform 0.1s;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
    }
    .control-btn:hover { opacity: 1; transform: scale(1.05); }
    .control-btn:active { transform: scale(0.95); }

    #fullscreenBtn { right: 12px; }
    #lockCursorBtn { right: 60px; }
    #popoutBtn { right: 108px; background: #3f51b5; }

    #progressContainer {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 6px;
      background: #2a2a2a;
      z-index: 10;
    }
    #progressBar {
      width: 0%;
      height: 100%;
      background: #4caf50;
      transition: width 0.2s;
    }

    #debugConsole {
        position: fixed;
        bottom: 0;
        right: 0;
        width: 400px;
        max-height: 50vh; 
        background: rgba(0, 0, 0, 0.9);
        border: 1px solid #333;
        border-radius: 8px 0 0 0;
        font-family: monospace;
        font-size: 10px;
        color: #ddd;
        padding: 8px;
        z-index: 20;
        box-shadow: -4px -4px 10px rgba(0, 0, 0, 0.5);
        transition: max-height 0.3s ease-in-out;
        overflow-y: auto; 
    }
    
    #debugConsole.minimized {
        max-height: 40px; 
        overflow-y: hidden; 
    }
    
    #debugConsole h4 {
        margin: 0;
        padding-bottom: 5px;
        border-bottom: 1px dashed #333;
        cursor: pointer;
        color: #4caf50;
        display: flex; 
        justify-content: space-between;
        align-items: center;
        user-select: none;
    }

    #debugConsole.minimized h4 {
        border-bottom: none; 
    }

    #debugConsole.minimized #logContent {
        display: none;
    }

    #toggleArrow {
        font-size: 14px;
        line-height: 1;
        margin-left: 10px;
        transition: transform 0.3s;
    }
    
    .log-item {
        padding: 2px 0;
        border-bottom: 1px dotted #222;
        line-height: 1.3;
        word-break: break-all;
    }
    .log-item:last-child { border-bottom: none; }
    .log-item.warn { color: #ffeb3b; }
    .log-item.error { color: #f44336; }
    .log-item.info { color: #81d4fa; }
  </style>
</head>
<body>
  <header>
    <label class="btn">
      <strong>Select ZIP (HTML/Unity)</strong>
      <input id="zip" type="file" accept=".zip" />
    </label>
    <label class="btn">
      <strong>Select HTML</strong>
      <input id="htmlFile" type="file" accept=".html,.htm" />
    </label>
    <label class="btn">
      <strong>Select SWF</strong>
      <input id="swfFile" type="file" accept=".swf" />
    </label>
    <select id="fileSelect"></select>
    <div id="status">No file loaded</div>
  </header>

  <div id="stageContainer">
    <iframe id="stage" class="stage-element blurry"
            tabindex="0"
            sandbox="allow-scripts allow-same-origin allow-downloads allow-pointer-lock allow-forms allow-modals allow-fullscreen"
            allowfullscreen
            referrerpolicy="no-referrer">
    </iframe>
  </div>
  
  <button id="popoutBtn" class="control-btn" title="Open in New Tab">â†—</button>
  <button id="lockCursorBtn" class="control-btn" title="Lock Cursor">ðŸ”’</button>
  <button id="fullscreenBtn" class="control-btn">â›¶</button>
  <div id="progressContainer"><div id="progressBar"></div></div>

  <div id="debugConsole" class="minimized">
      <h4 id="debugToggle">
          Runner Debug Log
          <span id="toggleArrow" aria-label="Expand">&#x25B2;</span> 
      </h4>
      <div id="logContent"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/fflate/umd/index.js"></script>
  <script src="https://unpkg.com/@ruffle-rs/ruffle"></script>

<script>
  const statusEl = document.getElementById('status');
  const stage = document.getElementById('stage');
  let currentStageElement = stage;
  const zipInput = document.getElementById('zip');
  const htmlInput = document.getElementById('htmlFile');
  const swfInput = document.getElementById('swfFile');
  const fileSelect = document.getElementById('fileSelect');
  const fullscreenBtn = document.getElementById('fullscreenBtn');
  const lockCursorBtn = document.getElementById('lockCursorBtn');
  const popoutBtn = document.getElementById('popoutBtn');
  const progressBar = document.getElementById('progressBar');
  const debugConsole = document.getElementById('debugConsole');
  const logContent = document.getElementById('logContent');
  const debugToggle = document.getElementById('debugToggle');
  const toggleArrow = document.getElementById('toggleArrow');

  let entries = {};
  let blobMap = {};
  let mapKeys = [];

  function log(message, type = 'info') {
    const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
    const formattedMessage = `[${timestamp}] ${message}`;
    
    if (type === 'error') console.error(formattedMessage);
    else if (type === 'warn') console.warn(formattedMessage);
    else console.log(formattedMessage);

    const logItem = document.createElement('div');
    logItem.className = `log-item ${type}`;
    logItem.textContent = formattedMessage;
    logContent.appendChild(logItem);
    
    if (!debugConsole.classList.contains('minimized')) {
        logContent.scrollTop = logContent.scrollHeight;
    }
  }

  debugToggle.addEventListener('click', () => {
    const isMinimized = debugConsole.classList.toggle('minimized');
    if (isMinimized) {
        toggleArrow.innerHTML = '&#x25B2;'; 
        toggleArrow.setAttribute('aria-label', 'Expand');
    } else {
        toggleArrow.innerHTML = '&#x25BC;'; 
        toggleArrow.setAttribute('aria-label', 'Minimize');
        setTimeout(() => logContent.scrollTop = logContent.scrollHeight, 300);
    }
  });

  popoutBtn.addEventListener('click', () => {
      window.open(window.location.href, '_blank');
      log('Opened runner in a new tab.', 'info');
  });

  function handleStageFocus(isFocused) {
      const targetElement = currentStageElement; 
      if (!targetElement) return;

      if (isFocused) {
          targetElement.classList.add('focused');
          targetElement.classList.remove('blurry');
          log('Game Stage focused.', 'info');
      } else {
          targetElement.classList.remove('focused');
          targetElement.classList.add('blurry');
      }
  }

  function setupFocusListeners() {
      currentStageElement.removeEventListener('focus', () => handleStageFocus(true));
      currentStageElement.removeEventListener('blur', () => handleStageFocus(false));
      currentStageElement.addEventListener('focus', () => handleStageFocus(true));
      currentStageElement.addEventListener('blur', () => handleStageFocus(false));
      
      if (currentStageElement === stage && stage.contentWindow) {
          try {
             stage.contentWindow.addEventListener('focus', () => handleStageFocus(true), true);
             stage.contentWindow.addEventListener('blur', () => handleStageFocus(false), true);
          } catch (e) {
             log(`Could not attach contentWindow focus listeners: ${e.message}`, 'error');
          }
      }
  }

  function resetStageToIframe() {
    const swfStage = document.getElementById('swfStage');
    if (swfStage && swfStage.parentNode) {
      swfStage.replaceWith(stage);
      currentStageElement = stage;
      stage.classList.add('stage-element');
      stage.classList.add('blurry'); 
      stage.classList.remove('focused');
    }
    setupFocusListeners();
  }
</script>
<script>
  function mimeType(name) {
    const lower = name.toLowerCase();
    if (lower.endsWith('.html') || lower.endsWith('.htm')) return 'text/html';
    if (lower.endsWith('.js')) return 'application/javascript';
    if (lower.endsWith('.css')) return 'text/css';
    if (lower.endsWith('.wasm')) return 'application/wasm';
    if (lower.includes('.data') || lower.includes('.unityweb')) return 'application/octet-stream'; 
    if (lower.endsWith('.json')) return 'application/json';
    if (lower.endsWith('.png')) return 'image/png';
    if (lower.endsWith('.jpg') || lower.endsWith('.jpeg')) return 'image/jpeg';
    if (lower.endsWith('.gif')) return 'image/gif';
    if (lower.endsWith('.webp')) return 'image/webp';
    if (lower.endsWith('.mp3')) return 'audio/mpeg';
    if (lower.endsWith('.ogg')) return 'audio/ogg';
    if (lower.endsWith('.mp4')) return 'video/mp4';
    if (lower.endsWith('.swf')) return 'application/x-shockwave-flash';
    return 'application/octet-stream';
  }
  
  // Safe buffer to Base64 (Chunked to avoid stack overflow)
  function bufferToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      let binary = '';
      const len = bytes.byteLength;
      const chunkSize = 0x8000; // 32KB
      for (let i = 0; i < len; i += chunkSize) {
          binary += String.fromCharCode.apply(null, bytes.subarray(i, Math.min(i + chunkSize, len)));
      }
      return window.btoa(binary);
  }

  function patchHtmlWithBlobs(name) {
    let raw = new TextDecoder().decode(entries[name]);
    let patchesApplied = 0;
    
    // --- PATCH 1: Standard attribute replacement ---
    raw = raw.replace(/(src|href|poster)=["']([^"']+)["']/gi, (match, attr, path) => {
      if (/^(https?:)?\/\//i.test(path)) return match;
      const clean = path.replace(/^["']|["']$/g, '').replace(/^\.?\/+/, '').split(/[?#]/)[0];
      if (blobMap[clean]) {
          patchesApplied++;
          return `${attr}="${blobMap[clean]}"`;
      }
      return match;
    });

    // --- PATCH 2: Unity Config URL Replacement ---
    raw = raw.replace(/(\w+Url\s*:\s*["'])([^"']+)(["'])/g, (match, prefix, path, suffix) => {
        const clean = path.replace(/^["']|["']$/g, '').replace(/^\.?\/+/, '').split(/[?#]/)[0];
        if (blobMap[clean]) {
            patchesApplied++;
            return `${prefix}${blobMap[clean]}${suffix}`;
        }
        return match;
    });

    // --- PATCH 3: Disable Web Workers ---
    raw = raw.replace(/(useWebWorkers\s*:\s*|webWorkerUrl\s*:\s*).+/g, (match) => {
        patchesApplied++;
        return `useWebWorkers: false, // Patched by ZIP Runner`;
    });
    
    // --- PATCH 4: Aggressive filename replacement ---
    for (const [fname, blobUrl] of Object.entries(blobMap)) {
      if (!blobUrl) continue;
      // Skip very long data URIs in aggressive search to prevent lag
      if (blobUrl.startsWith('data:') && blobUrl.length > 500) continue; 
      
      const safe = fname.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
      raw = raw.replace(new RegExp(`(["'])${safe}\\1`, 'g'), (match, quote) => {
        if (raw.includes(match)) {
            patchesApplied++;
            return `${quote}${blobUrl}${quote}`;
        }
        return match;
      });
    }

    // --- PATCH 5: SELF-CONTAINED ENVIRONMENT SHIM ---
    const blobMapJson = JSON.stringify(blobMap);
    const mapKeysJson = JSON.stringify(mapKeys);

    const injectionScriptContent = 
        '<script>\n' +
        '  (function() {\n' +
        '    console.log("Runner: Initializing environment shim...");\n' +
        '    var blobMap = ' + blobMapJson + ';\n' +
        '    var mapKeys = ' + mapKeysJson + ';\n' +
        '\n' +
        '    function resolve(path) {\n' +
        '        if (!path) return null;\n' +
        '        var clean = String(path).replace(/^["\']|["\']$/g, "").replace(/^\\.?\\/+/, "").split(/[?#]/)[0];\n' +
        '        if (blobMap[clean]) return blobMap[clean];\n' +
        '        var dir = clean + "/";\n' +
        '        if (mapKeys.some(function(k) { return k.indexOf(dir) === 0; })) return path;\n' +
        '        return path;\n' +
        '    }\n' +
        '\n' +
        '    if (typeof Module === "undefined") window.Module = {};\n' +
        '    Module.locateFile = function(path) { return resolve(path); };\n' +
        '    if (typeof UnityLoader !== "undefined" && UnityLoader.locateFile) {\n' +
        '        UnityLoader.locateFile = Module.locateFile;\n' +
        '    }\n' +
        '\n' +
        '    try {\n' +
        '       var noop = function() {};\n' +
        '       window.history.pushState = noop;\n' +
        '       window.history.replaceState = noop;\n' +
        '    } catch(e) { console.warn("Could not patch History API", e); }\n' +
        '\n' +
        '    try {\n' +
        '       window.Worker = function() {\n' +
        '          console.warn("Web Workers disabled by Runner.");\n' +
        '          return { postMessage: function() {}, terminate: function() {}, addEventListener: function() {} };\n' +
        '       };\n' +
        '    } catch(e) {}\n' +
        '  })();\n' +
        '<\/script>\n';

    if (raw.includes('<head>')) {
        raw = raw.replace('<head>', '<head>' + injectionScriptContent);
    } else if (raw.includes('<body>')) {
        raw = raw.replace('<body>', '<body>' + injectionScriptContent);
    } else {
        raw = injectionScriptContent + raw;
    }

    log(`HTML Patching Complete. Patches applied: ${patchesApplied}.`, 'info');
    return raw;
  }
</script>
<script>
  async function launchFile(name) {
    if (!entries[name]) return;
    logContent.innerHTML = '';
    log(`Attempting to launch: ${name}`);
    const fileNameOnly = name.split('/').pop();
    
    resetStageToIframe();

    if (fileNameOnly.toLowerCase().endsWith('.swf')) {
      const blobUrl = blobMap[fileNameOnly];
      
      const container = document.createElement('div');
      container.id = "swfStage";
      container.className = "stage-element blurry";
      
      stage.replaceWith(container);
      currentStageElement = container;
      setupFocusListeners();

      const ruffle = window.RufflePlayer.newest();
      const player = ruffle.createPlayer();
      player.style.width = "100%";
      player.style.height = "100%";
      container.appendChild(player);
      
      player.load(blobUrl);
      statusEl.textContent = `Running SWF: ${name}`;
      log(`SWF content loaded into Ruffle.`, 'info');
      return;
    }
    
    try {
      const patched = patchHtmlWithBlobs(name);
      const blob = new Blob([patched], { type: 'text/html' });
      const blobUrl = URL.createObjectURL(blob);
      stage.src = blobUrl;
      statusEl.textContent = `Running: ${name} (Unity/HTML)`;
      log(`Iframe source set to patched blob URL.`, 'info');
    } catch (e) {
        log(`Error during HTML patching/launch: ${e.message}`, 'error');
    }
  }
</script>
<script>
  zipInput.addEventListener('change', async () => {
    const file = zipInput.files?.[0];
    if (!file) return;
    
    resetStageToIframe();
    logContent.innerHTML = '';
    
    statusEl.textContent = `Reading ZIP: ${file.name}â€¦`;
    log(`Starting ZIP extraction for ${file.name}.`);
    
    try {
        const buf = new Uint8Array(await file.arrayBuffer());
        progressBar.style.width = '5%';

        const unzipped = fflate.unzipSync(buf);
        const names = Object.keys(unzipped);
        mapKeys = names;
        const total = names.length;
        entries = {};
        blobMap = {};
        log(`ZIP contains ${total} files. Processing...`, 'info');

        for (let idx = 0; idx < names.length; idx++) {
          const path = names[idx];
          const bytes = unzipped[path];
          
          if (path.endsWith('/')) continue;

          entries[path] = bytes;
          
          // --- KEY CHANGE: Use Data URIs for Scripts and CSS to prevent "Access Denied" ---
          let url;
          const mime = mimeType(path);
          const isScript = mime === 'application/javascript' || mime === 'text/css';
          
          // Use Data URI for scripts/css if file is smaller than 10MB to avoid stack overflow
          // This fixes the "Access to blob... denied" error by embedding the code directly.
          if (isScript && bytes.byteLength < 10 * 1024 * 1024) {
             const base64 = bufferToBase64(bytes);
             url = `data:${mime};base64,${base64}`;
          } else {
             const blob = new Blob([bytes], { type: mime });
             url = URL.createObjectURL(blob);
          }
          
          blobMap[path] = url;
          
          // Aggressive path mapping
          const parts = path.split('/');
          for (let i = 0; i < parts.length - 1; i++) { 
            const subPath = parts.slice(i + 1).join('/');
            if (!blobMap[subPath]) {
              blobMap[subPath] = url;
            }
          }
          
          const percent = Math.round(((idx + 1) / total) * 80) + 10;
          progressBar.style.width = percent + '%';
        }
        log('File data loaded. Scripts converted to Data URIs.', 'info');

        fileSelect.innerHTML = '';
        const runnableNames = names.filter(n => /\.html?$/i.test(n) || /\.swf$/i.test(n));
        runnableNames.forEach(n => {
          const opt = document.createElement('option');
          opt.value = n;
          opt.textContent = n;
          fileSelect.appendChild(opt);
        });

        const entry = runnableNames.find(n => /index\.html?$/i.test(n)) || runnableNames.find(n => /\.html?$/i.test(n)) || runnableNames[0];
        if (entry) {
          fileSelect.value = entry;
          await launchFile(entry);
          progressBar.style.width = '100%';
          setTimeout(() => progressBar.style.width = '0%', 1500);
        } else {
          statusEl.textContent = 'No entry point found.';
          log('No runnable entry point found.', 'error');
          progressBar.style.width = '0%';
        }
    } catch (e) {
        statusEl.textContent = `Error processing ZIP: ${e.message}`;
        log(`FATAL ZIP ERROR: ${e.message}`, 'error');
        progressBar.style.width = '0%';
    }
  });
</script>
<script>
  htmlInput.addEventListener('change', async () => {
    const file = htmlInput.files?.[0];
    if (!file) return;
    resetStageToIframe();
    logContent.innerHTML = '';
    
    try {
        const raw = await file.text();
        const blob = new Blob([raw], { type: 'text/html' });
        stage.src = URL.createObjectURL(blob);
        statusEl.textContent = `Running: ${file.name}`;
    } catch (e) {
        log(`Error loading HTML file: ${e.message}`, 'error');
    }
  });
</script>
<script>
  swfInput.addEventListener('change', async () => {
    const file = swfInput.files?.[0];
    if (!file) return;
    statusEl.textContent = `Loading SWF...`;
    
    try {
        const blobUrl = URL.createObjectURL(file);
        const container = document.createElement('div');
        container.id = "swfStage";
        container.className = "stage-element blurry";
        
        currentStageElement.replaceWith(container);
        currentStageElement = container;
        setupFocusListeners();

        const ruffle = window.RufflePlayer.newest();
        const player = ruffle.createPlayer();
        player.style.width = "100%";
        player.style.height = "100%";
        container.appendChild(player);
        player.load(blobUrl);
        statusEl.textContent = `Running SWF: ${file.name}`;
    } catch (e) {
        log(`Error loading SWF: ${e.message}`, 'error');
    }
  });
</script>
<script>
  fullscreenBtn.addEventListener('click', () => {
    const elem = currentStageElement;
    if (!document.fullscreenElement) {
      try {
        if (elem.requestFullscreen) elem.requestFullscreen();
        else if (elem.webkitRequestFullscreen) elem.webkitRequestFullscreen();
        else if (elem.msRequestFullscreen) elem.msRequestFullscreen();
      } catch (e) {
        log(`Fullscreen failed: ${e.message}`, 'error');
      }
    } else {
      if (document.exitFullscreen) document.exitFullscreen();
    }
  });

  function updatePointerLockBtn() {
    if (document.pointerLockElement) {
      lockCursorBtn.textContent = 'ðŸ”“';
      lockCursorBtn.title = 'Release Cursor';
    } else {
      lockCursorBtn.textContent = 'ðŸ”’';
      lockCursorBtn.title = 'Lock Cursor';
    }
  }

  document.addEventListener('pointerlockchange', updatePointerLockBtn);
  document.addEventListener('pointerlockerror', (e) => {
    log('Pointer Lock failed. Try the "Pop-out" button.', 'error');
    updatePointerLockBtn();
  });

  lockCursorBtn.addEventListener('click', () => {
    if (document.pointerLockElement) {
      document.exitPointerLock();
    } else {
      const target = (currentStageElement === stage && stage.contentWindow && stage.contentWindow.document.body) ? stage.contentWindow.document.body : currentStageElement;
      if (target.requestPointerLock) target.requestPointerLock();
    }
  });
  updatePointerLockBtn();
</script>
<script>
  stage.setAttribute("tabindex", "0");
  stage.addEventListener("load", () => {
    setupFocusListeners(); 
    handleStageFocus(false); 
    setTimeout(() => { stage.focus(); }, 100); 
  });
</script>
<script>
  window.addEventListener("keydown", (e) => {
    if (currentStageElement.classList.contains('focused') && 
        ["ArrowUp","ArrowDown","ArrowLeft","ArrowRight", "Space"].includes(e.key)) {
      e.preventDefault();
    }
    if (currentStageElement === stage && stage.contentWindow) {
      const forwarded = new KeyboardEvent("keydown", {
        key: e.key, code: e.code, keyCode: e.keyCode, which: e.which,
        altKey: e.altKey, ctrlKey: e.ctrlKey, shiftKey: e.shiftKey, metaKey: e.metaKey,
        bubbles: true, cancelable: true
      });
      stage.contentWindow.dispatchEvent(forwarded);
    }
  });
  
  document.body.addEventListener('click', () => {
    if (currentStageElement) {
        currentStageElement.focus();
        if (currentStageElement === stage && stage.contentWindow && stage.contentWindow.document.body) {
            stage.contentWindow.document.body.focus();
        }
    }
  });
</script>
</body>
</html>